<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DoxResource.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DoxDB REST API</a> &gt; <a href="index.source.html" class="el_package">net.trajano.doxdb.rest</a> &gt; <span class="el_source">DoxResource.java</span></div><h1>DoxResource.java</h1><pre class="source lang-java linenums">package net.trajano.doxdb.rest;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.StringReader;
import java.math.BigDecimal;
import java.net.URI;
import java.util.Date;
import java.util.List;
import java.util.Map.Entry;

import javax.ejb.EJB;
import javax.enterprise.context.RequestScoped;
import javax.json.Json;
import javax.json.JsonArrayBuilder;
import javax.json.JsonObject;
import javax.json.JsonObjectBuilder;
import javax.ws.rs.Consumes;
import javax.ws.rs.DELETE;
import javax.ws.rs.FormParam;
import javax.ws.rs.GET;
import javax.ws.rs.NotFoundException;
import javax.ws.rs.OPTIONS;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.CacheControl;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.EntityTag;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.PathSegment;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;
import javax.ws.rs.core.StreamingOutput;
import javax.ws.rs.core.UriBuilder;
import javax.ws.rs.core.UriInfo;
import javax.xml.bind.DatatypeConverter;

import net.trajano.doxdb.DoxID;
import net.trajano.doxdb.DoxMeta;
import net.trajano.doxdb.IndexView;
import net.trajano.doxdb.SearchResult;
import net.trajano.doxdb.ejb.DoxImport;
import net.trajano.doxdb.ejb.DoxLocal;
import net.trajano.doxdb.schema.CollectionType;
import net.trajano.doxdb.schema.LookupType;
import net.trajano.doxdb.schema.SchemaType;
import net.trajano.doxdb.ws.SessionManager;

/**
 * This provides the REST API for DoxDB. The API is built to support AngularJS
 * $resource natively.
 *
 * @author Archimedes Trajano
 */
@Path(&quot;&quot;)
@RequestScoped
<span class="nc" id="L66">public class DoxResource {</span>

    /**
     * Cache control when the data should not be cached.
     */
    private static final CacheControl NO_CACHE;

    /**
     * Cache control when the data can be cached. However, it should still not
     * be persisted on disk
     */
    private static final CacheControl OK_CACHE;

    /**
     * &lt;code&gt;application/json&lt;/code&gt; with the the UTF-8 character set. Needs to
     * be a constant string in order to be used in annotations.
     */
    private static final String RESPONSE_TYPE = &quot;application/json; charset=utf-8&quot;;

    static {
<span class="nc" id="L86">        NO_CACHE = new CacheControl();</span>
<span class="nc" id="L87">        NO_CACHE.setNoCache(true);</span>
<span class="nc" id="L88">        NO_CACHE.setNoStore(true);</span>
<span class="nc" id="L89">        NO_CACHE.setMaxAge(-1);</span>
<span class="nc" id="L90">        NO_CACHE.setProxyRevalidate(true);</span>
<span class="nc" id="L91">        NO_CACHE.setSMaxAge(-1);</span>
<span class="nc" id="L92">        NO_CACHE.setMustRevalidate(true);</span>

<span class="nc" id="L94">        OK_CACHE = new CacheControl();</span>
<span class="nc" id="L95">        OK_CACHE.setNoCache(false);</span>
<span class="nc" id="L96">        OK_CACHE.setNoStore(true);</span>
<span class="nc" id="L97">        OK_CACHE.setMaxAge(3600);</span>
<span class="nc" id="L98">        OK_CACHE.setProxyRevalidate(true);</span>
<span class="nc" id="L99">        OK_CACHE.setSMaxAge(-1);</span>
<span class="nc" id="L100">        OK_CACHE.setMustRevalidate(true);</span>
<span class="nc" id="L101">    }</span>

    @EJB
    private DoxLocal dox;

    @EJB
    private DoxImport doxImport;

    @EJB
    private SessionManager sessionManager;

    @POST
    @Path(&quot;search/{index}&quot;)
    @Produces(RESPONSE_TYPE)
    @Consumes(MediaType.APPLICATION_JSON)
    public Response advancedSearch(@PathParam(&quot;index&quot;) final String index,
        final JsonObject query,
        @Context final UriInfo uriInfo) {

<span class="nc" id="L120">        final SearchResult results = dox.advancedSearch(index, query);</span>
<span class="nc" id="L121">        final JsonObject resultJson = searchResultBuilder(uriInfo, results).build();</span>
<span class="nc" id="L122">        return Response.ok(resultJson).cacheControl(NO_CACHE).build();</span>
    }

    @POST
    @Path(&quot;search/{index}/{collectionName}&quot;)
    @Produces(RESPONSE_TYPE)
    @Consumes(MediaType.APPLICATION_JSON)
    public Response advancedSearchWithinCollection(@PathParam(&quot;index&quot;) final String index,
        @PathParam(&quot;collectionName&quot;) final String schemaName,
        final JsonObject query,
        @Context final UriInfo uriInfo) {

<span class="nc" id="L134">        final SearchResult results = dox.advancedSearch(index, schemaName, query);</span>
<span class="nc" id="L135">        final JsonObject resultJson = searchResultBuilder(uriInfo, results).build();</span>
<span class="nc" id="L136">        return Response.ok(resultJson).cacheControl(NO_CACHE).build();</span>
    }

    private String capitalize(final String s) {

<span class="nc bnc" id="L141" title="All 4 branches missed.">        if (s == null || s.isEmpty()) {</span>
<span class="nc" id="L142">            return s;</span>
        }
<span class="nc" id="L144">        final char[] a = s.toCharArray();</span>
<span class="nc" id="L145">        a[0] = Character.toUpperCase(a[0]);</span>
<span class="nc" id="L146">        return new String(a);</span>
    }

    /**
     * This will create the Dox object.
     *
     * @param collectionName
     *            collection name
     * @param content
     *            JSON content.
     * @return
     */
    @Path(&quot;{collectionName}&quot;)
    @POST
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(RESPONSE_TYPE)
    public Response create(@PathParam(&quot;collectionName&quot;) final String collectionName,
        final JsonObject content) {

<span class="nc" id="L165">        final DoxMeta meta = dox.create(collectionName, content);</span>
<span class="nc" id="L166">        sessionManager.sendMessage(&quot;CREATE&quot;, meta.getDoxId(), collectionName, meta.getLastUpdatedOn());</span>
<span class="nc" id="L167">        return Response.ok(meta.getContentJson()).lastModified(meta.getLastUpdatedOn()).build();</span>
    }

    @DELETE
    @Path(&quot;{collection}/{id}&quot;)
    public Response delete(@PathParam(&quot;collection&quot;) final String collection,
        @PathParam(&quot;id&quot;) final DoxID doxid,
        @QueryParam(&quot;v&quot;) final int version,
        @QueryParam(&quot;extra&quot;) final String extraJson) {

        JsonObject extra;
<span class="nc bnc" id="L178" title="All 2 branches missed.">        if (extraJson != null) {</span>
<span class="nc" id="L179">            extra = Json.createReader(new StringReader(extraJson)).readObject();</span>
        } else {
<span class="nc" id="L181">            extra = Json.createObjectBuilder().build();</span>
        }
<span class="nc" id="L183">        dox.delete(collection, doxid, version, extra);</span>
<span class="nc" id="L184">        sessionManager.sendMessage(&quot;DELETE&quot;, doxid, collection, new Date());</span>
<span class="nc" id="L185">        return Response.noContent().build();</span>
    }

    @POST
    @Path(&quot;export&quot;)
    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)
    @Produces(RESPONSE_TYPE)
    public Response doxExport(@FormParam(&quot;path&quot;) final String exportPath,
        @FormParam(&quot;schema&quot;) final String schema,
        @FormParam(&quot;from&quot;) final String fromLastUpdatedOnString) {

        Date fromLastUpdatedOn;
<span class="nc bnc" id="L197" title="All 2 branches missed.">        if (fromLastUpdatedOnString == null) {</span>
<span class="nc" id="L198">            fromLastUpdatedOn = null;</span>

        } else {
<span class="nc" id="L201">            fromLastUpdatedOn = DatatypeConverter.parseDateTime(fromLastUpdatedOnString).getTime();</span>
        }

<span class="nc" id="L204">        return Response.ok(doxImport.exportDox(exportPath, schema, fromLastUpdatedOn)).cacheControl(NO_CACHE).build();</span>
    }

    @POST
    @Path(&quot;import&quot;)
    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)
    @Produces(RESPONSE_TYPE)
    public Response doxImport(@FormParam(&quot;path&quot;) final String importPath) {

<span class="nc" id="L213">        return Response.ok(doxImport.importDox(importPath)).cacheControl(NO_CACHE).build();</span>
    }

    @GET
    @Path(&quot;{collection}/{id}&quot;)
    @Produces(RESPONSE_TYPE)
    public Response get(@PathParam(&quot;collection&quot;) final String collectionName,
        @PathParam(&quot;id&quot;) final DoxID doxId) {

<span class="nc" id="L222">        final DoxMeta meta = dox.read(collectionName, doxId);</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (meta == null) {</span>
<span class="nc" id="L224">            return Response.status(Status.NOT_FOUND).type(MediaType.TEXT_PLAIN).entity(&quot;Dox not found&quot;).build();</span>
        }
<span class="nc" id="L226">        final EntityTag entityTag = new EntityTag(String.valueOf(meta.getVersion()));</span>
<span class="nc" id="L227">        return Response.ok(meta.getContentJson()).cacheControl(OK_CACHE).tag(entityTag).lastModified(meta.getLastUpdatedOn()).build();</span>
    }

    /**
     * In addition to the default operations, the lookup operations will also be
     * provided as the string &quot;getBy{lookupName}&quot; for unique lookups. Note that
     * lookupName will have it's first character capitalized.
     *
     * @param uriInfo
     * @return
     */
    @GET
    @Path(&quot;module.js&quot;)
    @Produces(&quot;application/javascript&quot;)
    public Response getAngularModule(final @Context UriInfo uriInfo) {

<span class="nc" id="L243">        final StreamingOutput out = new StreamingOutput() {</span>

            @Override
            public void write(final OutputStream os) throws IOException,
                WebApplicationException {

<span class="nc" id="L249">                try (final PrintStream w = new PrintStream(os)) {</span>
<span class="nc" id="L250">                    w.println(&quot;\&quot;use strict\&quot;;&quot;);</span>
<span class="nc" id="L251">                    w.print(&quot;(function(){&quot;);</span>
                    //                    w.print(&quot;function s(d){&quot;);
                    //                    w.print(&quot;delete d._id;&quot;);
                    //                    w.print(&quot;delete d._v;&quot;);
                    //                    w.print(&quot;}&quot;);
<span class="nc" id="L256">                    w.print(&quot;angular.module('doxdb',['ngResource'])&quot;);</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">                    for (final CollectionType collectionType : dox.getConfiguration().getCollection()) {</span>
<span class="nc" id="L258">                        final String name = collectionType.getName();</span>
<span class="nc" id="L259">                        w.print(&quot;.factory('DoxDB&quot; + name + &quot;', ['$resource',function(r){&quot;);</span>
<span class="nc" id="L260">                        final String uri = uriInfo.getBaseUriBuilder().path(name).build() + &quot;/:id?v=:version&quot;;</span>
<span class="nc" id="L261">                        w.print(&quot;return r('&quot; + uri + &quot;',{'id':'@_id','version':'@_version'},{&quot;);</span>

<span class="nc" id="L263">                        final SchemaType currentSchemaType = collectionType.getSchema().get(collectionType.getSchema().size() - 1);</span>

<span class="nc bnc" id="L265" title="All 2 branches missed.">                        for (final LookupType LookupType : currentSchemaType.getUnique()) {</span>
<span class="nc" id="L266">                            final String lookupUri = uriInfo.getBaseUriBuilder().path(name).build() + &quot;/&quot; + LookupType.getName() + &quot;/:lookupKey&quot;;</span>
<span class="nc" id="L267">                            w.print(&quot;'getBy&quot; + capitalize(LookupType.getName()) + &quot;':{method:'GET',url:'&quot; + lookupUri + &quot;'},&quot;);</span>
<span class="nc" id="L268">                        }</span>

<span class="nc" id="L270">                        w.print(&quot;});&quot;);</span>
<span class="nc" id="L271">                        w.print(&quot;}])&quot;);</span>
<span class="nc" id="L272">                    }</span>
<span class="nc" id="L273">                    w.print(&quot;;})();&quot;);</span>
<span class="nc bnc" id="L274" title="All 8 branches missed.">                }</span>
<span class="nc" id="L275">            }</span>
        };

<span class="nc" id="L278">        return Response.ok(out).cacheControl(OK_CACHE).tag(dox.toString()).build();</span>
    }

    /**
     * Returns the schema document. It does a check to make sure each path
     * segment contains a restricted set of characters.
     *
     * @param segments
     *            path segments after the URL
     * @return the schema document.
     */
    @GET
    @Path(&quot;schema/{segments: .*}&quot;)
    @Produces(RESPONSE_TYPE)
    public Response getSchema(@PathParam(&quot;segments&quot;) final List&lt;PathSegment&gt; segments) {

<span class="nc" id="L294">        final UriBuilder b = UriBuilder.fromUri(&quot;schema&quot;);</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">        for (final PathSegment segment : segments) {</span>
<span class="nc" id="L296">            final String pathSegment = segment.getPath();</span>
<span class="nc bnc" id="L297" title="All 8 branches missed.">            if (&quot;.&quot;.equals(pathSegment) || &quot;..&quot;.equals(pathSegment) || pathSegment.endsWith(&quot;.&quot;) || !pathSegment.matches(&quot;^[-A-Za-z0-9_\\.]+$&quot;)) {</span>
<span class="nc" id="L298">                throw new WebApplicationException(&quot;invalid request&quot;);</span>
            }
<span class="nc" id="L300">            b.path(pathSegment);</span>
<span class="nc" id="L301">        }</span>
<span class="nc" id="L302">        final URI relativize = UriBuilder.fromUri(&quot;schema&quot;).build().relativize(b.build());</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (relativize.isAbsolute()) {</span>
<span class="nc" id="L304">            throw new WebApplicationException(&quot;invalid request&quot;);</span>
        }

<span class="nc" id="L307">        final StreamingOutput out = new StreamingOutput() {</span>

            @Override
            public void write(final OutputStream os) throws IOException,
                WebApplicationException {

<span class="nc" id="L313">                try (InputStream fis = dox.getSchema(relativize.toASCIIString())) {</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">                    if (fis == null) {</span>
<span class="nc" id="L315">                        throw new NotFoundException();</span>
                    }
<span class="nc" id="L317">                    int c = fis.read();</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">                    while (c != -1) {</span>
<span class="nc" id="L319">                        os.write(c);</span>
<span class="nc" id="L320">                        c = fis.read();</span>
                    }
<span class="nc bnc" id="L322" title="All 8 branches missed.">                }</span>

<span class="nc" id="L324">            }</span>
        };
<span class="nc" id="L326">        return Response.ok(out).encoding(&quot;UTF-8&quot;).build();</span>
    }

    @POST
    @Path(&quot;{collection}/{id}/lock&quot;)
    @Produces(RESPONSE_TYPE)
    public Response lock(@PathParam(&quot;collection&quot;) final String collectionName,
        @PathParam(&quot;id&quot;) final DoxID doxId) {

<span class="nc" id="L335">        final int lockId = dox.lock(collectionName, doxId);</span>
<span class="nc" id="L336">        final JsonObject lockJson = Json.createObjectBuilder().add(&quot;lockId&quot;, lockId).build();</span>
<span class="nc" id="L337">        sessionManager.sendMessage(&quot;LOCK&quot;, doxId, collectionName, new Date());</span>
<span class="nc" id="L338">        return Response.ok(lockJson).cacheControl(NO_CACHE).build();</span>
    }

    /**
     * This will return either an array or a single JsobObject depending on
     * whether the lookup is for unique or not.
     *
     * @param collectionName
     *            collection name
     * @param lookupName
     *            lookup name (can be either unique or not)
     * @param lookupKey
     *            lookup key
     * @return array or a single JsobObject depending on whether the lookup is
     *         for unique or not.
     */
    @GET
    @Path(&quot;{collectionName}/{lookupName}/{lookupKey}&quot;)
    @Produces(RESPONSE_TYPE)
    public Response lookup(@PathParam(&quot;collectionName&quot;) final String collectionName,
        @PathParam(&quot;lookupName&quot;) final String lookupName,
        @PathParam(&quot;lookupKey&quot;) final String lookupKey,
        @Context final UriInfo uriInfo) {

<span class="nc" id="L362">        SchemaType schema = null;</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">        for (final CollectionType collection : dox.getConfiguration().getCollection()) {</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">            if (collection.getName().equals(collectionName)) {</span>
<span class="nc" id="L365">                schema = collection.getSchema().get(collection.getSchema().size() - 1);</span>
<span class="nc" id="L366">                break;</span>
            }
<span class="nc" id="L368">        }</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">        if (schema == null) {</span>
<span class="nc" id="L370">            return Response.status(Status.NOT_FOUND).build();</span>
        }

<span class="nc bnc" id="L373" title="All 2 branches missed.">        for (final LookupType lookup : schema.getUnique()) {</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">            if (lookup.getName().equals(lookupName)) {</span>
<span class="nc" id="L375">                final DoxMeta meta = dox.readByUniqueLookup(collectionName, lookupName, lookupKey);</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">                if (meta == null) {</span>
<span class="nc" id="L377">                    return Response.status(Status.NOT_FOUND).type(MediaType.TEXT_PLAIN).entity(&quot;Dox not found&quot;).build();</span>
                }
<span class="nc" id="L379">                final EntityTag entityTag = new EntityTag(String.valueOf(meta.getVersion()));</span>
<span class="nc" id="L380">                final URI location = uriInfo.getBaseUriBuilder().path(collectionName).path(meta.getDoxId().toString()).build();</span>
<span class="nc" id="L381">                return Response.seeOther(location).cacheControl(OK_CACHE).tag(entityTag).lastModified(meta.getLastUpdatedOn()).build();</span>
            }
<span class="nc" id="L383">        }</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">        for (final LookupType lookup : schema.getLookup()) {</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">            if (lookup.getName().equals(lookupName)) {</span>
<span class="nc" id="L386">                return Response.ok(dox.readByLookup(collectionName, lookupName, lookupKey)).build();</span>
            }
<span class="nc" id="L388">        }</span>
<span class="nc" id="L389">        return Response.status(Status.NOT_FOUND).build();</span>

    }

    @GET
    @Path(&quot;{collection}&quot;)
    @Produces(RESPONSE_TYPE)
    public Response readAll(@PathParam(&quot;collection&quot;) final String collection) {

<span class="nc" id="L398">        final String readAll = dox.readAll(collection);</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">        if (readAll.charAt(0) == '[') {</span>
<span class="nc" id="L400">            return Response.ok(readAll).build();</span>
        }

        // The file is suffixed with the uncompressed size

<span class="nc" id="L405">        final File file = new File(readAll);</span>
<span class="nc" id="L406">        final long uncompressedSize = file.length();</span>
<span class="nc" id="L407">        final StreamingOutput out = new StreamingOutput() {</span>

            @Override
            public void write(final OutputStream os) throws IOException,
                WebApplicationException {

<span class="nc" id="L413">                try (final InputStream fis = new BufferedInputStream(new FileInputStream(file))) {</span>
<span class="nc" id="L414">                    int c = fis.read();</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">                    while (c != -1) {</span>
<span class="nc" id="L416">                        os.write(c);</span>
<span class="nc" id="L417">                        c = fis.read();</span>
                    }
<span class="nc bnc" id="L419" title="All 8 branches missed.">                } finally {</span>
<span class="nc" id="L420">                    file.delete();</span>
<span class="nc" id="L421">                }</span>
<span class="nc" id="L422">            }</span>

        };

<span class="nc" id="L426">        return Response.ok(out).cacheControl(NO_CACHE).header(&quot;Content-Encoding&quot;, &quot;gzip&quot;).header(&quot;Content-Length&quot;, uncompressedSize).build();</span>

    }

    @OPTIONS
    @Path(&quot;reindex&quot;)
    public Response reindex() {

        // TODO remove this later.
<span class="nc" id="L435">        dox.reindex();</span>
<span class="nc" id="L436">        return Response.noContent().build();</span>
    }

    @POST
    @Path(&quot;{collectionName}/{id}&quot;)
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(RESPONSE_TYPE)
    public Response save(@PathParam(&quot;collectionName&quot;) final String collection,
        @PathParam(&quot;id&quot;) final String id,
        final JsonObject json,
        @QueryParam(&quot;v&quot;) final int version) {

<span class="nc" id="L448">        final DoxMeta meta = dox.update(collection, new DoxID(id), json, version);</span>
<span class="nc" id="L449">        sessionManager.sendMessage(&quot;UPDATE&quot;, meta.getDoxId(), collection, meta.getLastUpdatedOn());</span>
<span class="nc" id="L450">        return Response.ok(meta.getContentJson()).lastModified(meta.getLastUpdatedOn()).build();</span>
    }

    @POST
    @Path(&quot;{collection}/{id}/{oobname}&quot;)
    @Produces(MediaType.APPLICATION_OCTET_STREAM)
    public Response saveOob(@PathParam(&quot;collection&quot;) final String collection,
        @PathParam(&quot;id&quot;) final DoxID id,
        @PathParam(&quot;oobname&quot;) final String oobname) {

<span class="nc" id="L460">        return Response.ok().type(RESPONSE_TYPE).entity(&quot;OOB&quot;).build();</span>
    }

    /**
     * This builds the search result object except for the link to the next
     * page.
     *
     * @param uriInfo
     *            context to build the URI
     * @param results
     *            the search results from the EJB
     * @return JSON Object builder
     */
    private JsonObjectBuilder searchResultBuilder(final UriInfo uriInfo,
        final SearchResult results) {

        final JsonObjectBuilder jsonBuilder;
<span class="nc" id="L477">        final JsonArrayBuilder hitsBuilder = Json.createArrayBuilder();</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">        for (final IndexView hit : results.getHits()) {</span>
<span class="nc" id="L479">            final JsonObjectBuilder hitBuilder = Json.createObjectBuilder();</span>
<span class="nc" id="L480">            final String id = hit.getDoxID().toString();</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">            for (final Entry&lt;String, BigDecimal&gt; entry : hit.getNumbers()) {</span>
<span class="nc" id="L482">                hitBuilder.add(entry.getKey(), entry.getValue());</span>
<span class="nc" id="L483">            }</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">            for (final Entry&lt;String, String&gt; entry : hit.getStrings()) {</span>
<span class="nc" id="L485">                hitBuilder.add(entry.getKey(), entry.getValue());</span>
<span class="nc" id="L486">            }</span>
<span class="nc" id="L487">            hitBuilder.add(&quot;_collection&quot;, hit.getCollection());</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">            if (!hit.isMasked()) {</span>
<span class="nc" id="L489">                hitBuilder.add(&quot;_id&quot;, id);</span>
<span class="nc" id="L490">                hitBuilder.add(&quot;_url&quot;, uriInfo.getBaseUriBuilder().path(hit.getCollection()).path(id).build().toString());</span>
            }
<span class="nc" id="L492">            hitsBuilder.add(hitBuilder);</span>
<span class="nc" id="L493">        }</span>
<span class="nc" id="L494">        jsonBuilder = Json.createObjectBuilder().add(&quot;totalHits&quot;, results.getTotalHits()).add(&quot;hits&quot;, hitsBuilder);</span>
<span class="nc" id="L495">        return jsonBuilder;</span>
    }

    @GET
    @Path(&quot;search/{index}&quot;)
    @Produces(RESPONSE_TYPE)
    public Response simpleSearch(@PathParam(&quot;index&quot;) final String index,
        @QueryParam(&quot;q&quot;) final String queryString,
        @QueryParam(&quot;f&quot;) final Integer from,
        @Context final UriInfo uriInfo) {

<span class="nc" id="L506">        final SearchResult results = dox.search(index, queryString, 50, from);</span>
<span class="nc" id="L507">        final JsonObjectBuilder resultBuilder = searchResultBuilder(uriInfo, results);</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">        if (results.getBottomDoc() != null) {</span>
<span class="nc" id="L509">            final String nextPage = uriInfo.getBaseUriBuilder().path(&quot;search&quot;).path(index).queryParam(&quot;q&quot;, queryString).queryParam(&quot;f&quot;, results.getBottomDoc()).build().toASCIIString();</span>
<span class="nc" id="L510">            resultBuilder.add(&quot;bottomDoc&quot;, results.getBottomDoc()).add(&quot;next&quot;, nextPage);</span>
        }
<span class="nc" id="L512">        final JsonObject resultJson = resultBuilder.build();</span>
<span class="nc" id="L513">        return Response.ok(resultJson).cacheControl(NO_CACHE).build();</span>
    }

    @GET
    @Path(&quot;search/{index}/{schemaName}&quot;)
    @Produces(RESPONSE_TYPE)
    public Response simpleSearchWithSchemaName(@PathParam(&quot;index&quot;) final String index,
        @PathParam(&quot;schemaName&quot;) final String schemaName,
        @QueryParam(&quot;q&quot;) final String queryString,
        @QueryParam(&quot;f&quot;) final Integer from,
        @Context final UriInfo uriInfo) {

<span class="nc" id="L525">        final SearchResult results = dox.searchWithCollectionName(index, schemaName, queryString, 50, from);</span>
<span class="nc" id="L526">        final JsonObjectBuilder resultBuilder = searchResultBuilder(uriInfo, results);</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">        if (results.getBottomDoc() != null) {</span>
<span class="nc" id="L528">            final String nextPage = uriInfo.getBaseUriBuilder().path(&quot;search&quot;).path(index).path(schemaName).queryParam(&quot;q&quot;, queryString).queryParam(&quot;f&quot;, results.getBottomDoc()).build().toASCIIString();</span>
<span class="nc" id="L529">            resultBuilder.add(&quot;bottomDoc&quot;, results.getBottomDoc()).add(&quot;next&quot;, nextPage);</span>
        }
<span class="nc" id="L531">        final JsonObject resultJson = resultBuilder.build();</span>
<span class="nc" id="L532">        return Response.ok(resultJson).cacheControl(NO_CACHE).build();</span>
    }

    @DELETE
    @Path(&quot;{collection}/{id}/lock/{lockId}&quot;)
    @Produces(RESPONSE_TYPE)
    public Response unlock(@PathParam(&quot;collection&quot;) final String collectionName,
        @PathParam(&quot;id&quot;) final DoxID doxId,
        @PathParam(&quot;lockId&quot;) final int lockId) {

<span class="nc" id="L542">        dox.unlock(collectionName, doxId, lockId);</span>
<span class="nc" id="L543">        sessionManager.sendMessage(&quot;UNLOCK&quot;, doxId, collectionName, new Date());</span>
<span class="nc" id="L544">        return Response.noContent().build();</span>

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>